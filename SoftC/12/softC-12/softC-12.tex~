\documentclass [a4j] {jarticle}

\begin{document}

\section{main.c}
\begin{verbatim}
#include "function.h"

int main()
{
  int i;
  char chose[MAXLEN];
  struct cell_f **f;
  struct cell_c **c;
  struct cell_f *head_f = NULL;
  struct cell_c *head_c = NULL;
  struct cell_f *h_f = NULL;
  FILE *fp_f, *fp_c;

  printf("Welcome!\n");

  if ((fp_f = fopen("original_file.dat", "r")) == NULL){
    fprintf(stderr, "Cannot open file: original_filet.dat\n");
    return;
  }

  if ((fp_c = fopen("category_list.dat", "r")) == NULL){
    fprintf(stderr, "Cannot open file: category_list.dat\n");
    return;
  }


  f = make_original_file_list(&head_f, fp_f);
  c = make_original_category_list(&head_c, fp_c);

  i = 0;

  while(i != 1){
    printf("機能一覧を表示します。\n");
    printf("0: 新規ファイルの登録 \n1: 既存ファイルの削除 \n2: 任意のファイル、任意の項目への修正 \n3: 既存のファイルの検索 \n4: 新たな分類項目の追加 \n5: 既存の分類項目の削除 \n6: 任意のファイルのコメント抽出\n");
    printf(">");
    scanf("%s", chose);

    if(strlen(chose) > 1){
      printf("入力エラーです。\n");
      continue;
    }

    switch (chose[0]) {
    case '0':
      insert_cell_file(c, f);
      break;

    case '1':
      delete_file(f);
      break;

    case '2':
      rename_file(f);
      break;

    case '3':
      search_f(&h_f, f);
      delete_cell(&h_f);
      break;

    case '4':
      insert_cell_category(c);
      break;

    case '5':
      delete_category(c);
      break;

    case '6':
      sub_function(f);
      break;

    default:
      printf("入力エラーです。\n");
      break;

    }

    printf("アプリケーションの実行を続けますか？\n");
    printf("0: Yes 1: No\n");
    printf(">");
    scanf("%d", &i);
    while(i != 0 && i != 1){
      printf("アプリケーションの実行を続けますか？\n");
      printf("0: Yes 1: No\n");
      printf(">");
      scanf("%d", &i);
    }
  }

  fclose(fp_f);
  fclose(fp_c);

  if ((fp_f = fopen("original_file.dat", "w")) == NULL){
    fprintf(stderr, "Cannot open file: original_filet.dat\n");
    return;
  }

  if ((fp_c = fopen("category_list.dat", "w")) == NULL){
    fprintf(stderr, "Cannot open file: original_filet.dat\n");
    return;
  }

  while((*f) != NULL){
    fprintf(fp_f, "%s %s %s %s %d\n", (*f)->main_title, (*f)->sub_title, (*f)->date, (*f)->path, (*f)->category);
    (*f) = (*f)->next;
  }

  while((*c) != NULL){
    fprintf(fp_c, "%d %s\n", (*c)->number, (*c)->category);
    (*c) = (*c)->next;
  }

  fclose(fp_f);
  fclose(fp_c);

  return 0;
}
\end{verbatim}

\section{function.h}
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct cell_f{
  char *main_title;
  char *sub_title;
  char *date;
  char *path;
  int category;
  struct cell_f *next;
};

struct cell_c{
  int number;
  char *category;
  struct cell_c *next;
};

#define MAXLEN 100
#define MAX 2000

void insert_cell_f(struct cell_f **pointer, char *main_title, char *sub_title, char *date, char *path, int category);
struct cell_f **make_original_file_list(struct cell_f **pointer, FILE *fp);

void insert_cell_c(struct cell_c **pointer, int new_number, char *new_category);
struct cell_c **make_original_category_list(struct cell_c **pointer, FILE *fp);

void insert_cell_file(struct cell_c **p, struct cell_f **pointer);

void delete_file(struct cell_f **pointer);

void insert_cell_category(struct cell_c **pointer);
int search_n(struct cell_c *a, int n);
int search_c(struct cell_c *a, char *category);

void delete_category(struct cell_c **pointer);
void replace_number(struct cell_c *pointer);

void rename_file(struct cell_f **pointer);

void sort(struct cell_f **pointer);

struct cell_f *search(struct cell_f *pointer, int n);
void change(struct cell_f *data, int x, int y);

void category_a(struct cell_f **pointer);
void downheap_category_a(struct cell_f *data, int v, int n);

void category_d(struct cell_f **pointer);
void downheap_category_d(struct cell_f *data, int v, int n);

void date_a(struct cell_f **p);
void downheap_date_a(struct cell_f *data, int v, int n);

void date_d(struct cell_f **pointer);
void downheap_date_d(struct cell_f *data, int v, int n);

void m_a_sub_a(struct cell_f **pointer);
void downheap_main_a_sub_a(struct cell_f *data, int v, int n);

void m_a_sub_d(struct cell_f **pointer);
void downheap_main_a_sub_d(struct cell_f *data, int v, int n);

void m_d_sub_a(struct cell_f **pointer);
void downheap_main_d_sub_a(struct cell_f *data, int v, int n);

void m_d_sub_d(struct cell_f **pointer);
void downheap_main_d_sub_d(struct cell_f *data, int v, int n);

void path_a(struct cell_f **pointer);
void downheap_path_a(struct cell_f *data, int v, int n);

void path_d(struct cell_f **pointer);
void downheap_path_d(struct cell_f *data, int v, int n);

void print_f(struct cell_f *p);
void print_c(struct cell_c *p);

void search_f(struct cell_f **h_f, struct cell_f **pointer);
struct cell_f **search_file(struct cell_f **h_f, struct cell_f *pointer, int number, char *key);

void delete_cell(struct cell_f **pointer);

void sub_function(struct cell_f **pointer);

void insert_cell_new_category(struct cell_c **pointer, char *new_category);

\end{verbatim}

\section{correct_file.c}
\begin{verbatim}
#include "function.h"

void rename_file(struct cell_f **pointer)
{
  struct cell_f *p, *q;
  int data;
  char key[MAXLEN];
  char main[MAXLEN], sub[MAXLEN];

  printf("修正するファイルを検索します。\n");

  printf("修正するファイルのタイトル名を入力してください。\n");
  printf(">");
  scanf("%s", main);

  printf("修正するファイルの副タイトル名を入力してください。\n");
  printf(">");
  scanf("%s", sub);


  p = *pointer;

  while(p != NULL && (strcmp(p->main_title, main)) != 0 && (strcmp(p->sub_title, sub)) != 0){
    q = p;
    p = p->next;
  }

  if(p == NULL){
    printf("一致するファイルはありませんでした。\n");
    return;
  }

  else{
    printf("%s %s %s %s %d\n", p->main_title, p->sub_title, p->date, p->path, p->category);
    printf("修正する項目を選択してください。\n");
    printf("0: タイトル 1: 副タイトル 2: 作成日付 3: パス名 4: 分類項目名\n");
    printf(">");
    scanf("%d", &data);
    if(0 >= data && data >= 4){
      printf("入力が間違っています。\n");
      return;
    }

    printf("修正後のデータを入力してください。\n");
    printf(">");
    scanf("%s", key);

    if(data == 0)
      strcpy((*pointer)->main_title, key);
	
    else if(data == 1)
      strcpy(p->sub_title, key);

    else if(data == 2)
      strcpy(p->date, key);

    else if(data == 3)
      strcpy(p->path, key);

    else if(data == 4)
      p->category = atoi(key);

    printf("データの修正が完了しました。\n");
  }
}

\end{verbatim}

\section{delete_existing_category.c}
\begin{verbatim}
#include "function.h"

void delete_category(struct cell_c **pointer)
{
  struct cell_c *p, *q;
  int a;
  int number;
  char category[MAXLEN];

  p = *pointer;

  printf("削除する分類項目を検索します。\n");

  print_c(p);

  printf("削除する分類項目の分類項目番号を入力してください。\n");
  printf(">");
  scanf("%d", &number);

  printf("削除する分類項目名を入力してください。\n");
  printf(">");
  scanf("%s", category);

  while(p != NULL && p->number != number && (strcmp(p->category, category)) != 0){
    q = p;

    p = p->next;
  }

  if(p == NULL){
    printf("一致する分類項目はありませんでした。\n");
    return;
  }

  else{
    printf("%d %s\n", p->number, p->category);
    printf("この分類項目を本当に削除しますか？");
    printf("0: Yes 1: No\n");
    printf(">");

    scanf("%d", &a);

    if(a == 1){
      printf("削除をキャンセルしました。");
      return;
    }

    else if(a == 0){
      if(p == *pointer){
        *pointer = p->next;
        free((void *)p);
      }
      else{
        q->next = p->next;
        free(p);
      }
      printf("削除が完了しました。\n");
      replace_number(q->next);
    }
  }
}

void replace_number(struct cell_c *pointer)
{
  while(pointer != NULL){
    pointer->number = pointer->number - 1;
    pointer = pointer->next;
  }
}

\end{verbatim}

\section{delete_existing_file.c}
\begin{verbatim}
#include "function.h"

void delete_file(struct cell_f **pointer)
{
  struct cell_f *p, *q;
  char a[MAXLEN];
  char main[MAXLEN], sub[MAXLEN];

  printf("削除するファイルを検索します。\n");

  printf("削除するファイルのタイトル名を入力してください。\n");
  printf(">");
  scanf("%s", main);

  printf("削除するファイルの副タイトル名を入力してください。\n");
  printf(">");
  scanf("%s", sub);

  p = *pointer;

  while(p != NULL && (strcmp(p->main_title, main)) != 0 && (strcmp(p->sub_title, sub)) != 0){
    q = p;
    p = p->next;
  }

  if(p == NULL){
    printf("一致するファイルはありませんでした。\n");
    return;
  }

  else{
    printf("%s %s %s %s %d\n", p->main_title, p->sub_title, p->date, p->path, p->category);
    printf("このファイルを本当に削除しますか？");
    printf("0: Yes 1: No\n");
    printf(">");

    scanf("%s", a);

    if(strlen(a) > 1){
      printf("入力エラーです。\n");
      return;
    }

    if(atoi(a) == 1){
      printf("削除をキャンセルしました。");
      return;
    }

    else if(atoi(a) == 0){
      if(p == *pointer){
        *pointer = p->next;
        free((void *)p);
      }
      else{
        q->next = p->next;
        free((void *)p);
      }

      printf("削除が完了しました。\n");
      printf("ファイル一覧を表示します。\n");
      print_f((*pointer));
    }
  }
}

\end{verbatim}

\section{free_file_cell.c}
\begin{verbatim}
#include "function.h"

void delete_cell(struct cell_f **pointer)
{
	struct cell_f *target;

	while((*pointer) != NULL){
		target = *pointer;
		*pointer = target->next;
		free((void *)target);
		(*pointer) = (*pointer)->next;
	}
}

\end{verbatim}

\section{make_new_file.c}
\begin{verbatim}
#include "function.h"

void insert_cell_file(struct cell_c **p, struct cell_f **pointer)
{
  char main_title[MAXLEN], sub_title[MAXLEN], date[MAXLEN], path[MAXLEN], category[MAXLEN];
  int s_n;

  printf("新しいファイルを登録します。\n");

  printf("ファイルのタイトル名を入力してください。(例: softC)\n>");
  scanf("%s", main_title);

  printf("ファイルの副タイトル名を入力してください。(例: メインルーチン)\n>");
  scanf("%s", sub_title);

  printf("ファイルの作成日付を入力してください。(例: 10/18/2010)\n>");
  scanf("%s", date);

  printf("ファイルのパス名を入力してください。(例: /g031h105/softC)\n>");
  scanf("%s", path);

  printf("ファイルの分類番号を入力してください。(例: 3)\n>");
  scanf("%s", category);

  if(strlen(category) > 1){
    printf("入力エラーです。\n");
    return;
  }

  s_n = 0;
  while(s_n != 1){
    if((s_n = (search_n((*p), atoi(category)))) != 1){
      printf("その分類番号は登録されていません。\n");
      printf("ファイルの分類番号を入力してください。(例: 3)\n>");
      scanf("%s%*c", category);
    }
    if(strlen(category) > 1){
      printf("入力エラーです。\n");
      return;
    }
  }

  insert_cell_f(pointer, main_title, sub_title, date, path, atoi(category));

  printf("ファイルを登録しました。\n");
  printf("%s %s %s %s %d\n", (*pointer)->main_title, (*pointer)->sub_title, (*pointer)->date, (*pointer)->path, (*pointer)->category);
}

\end{verbatim}

\section{make_original_category_list.c}
\begin{verbatim}
#include "function.h"

void insert_cell_c(struct cell_c **pointer,int new_number, char *new_category)
{
  struct cell_c *new_cell;

  new_cell = (struct cell_c *)malloc(sizeof(struct cell_c));
  new_cell->category = (char *)malloc(strlen(new_category) + 1);

  new_cell->number = new_number;
  strcpy(new_cell->category, new_category);
  new_cell->next = *pointer;
  *pointer = new_cell;
}

struct cell_c **make_original_category_list(struct cell_c **pointer, FILE *fp)
{
  struct cell_c **p;
  int number;
  char category[MAXLEN];

  p = pointer;

  while(fscanf(fp, "%d %s", &number, category) != EOF){
    insert_cell_c(p, number, category);
    p = &((*p)->next);
  }

  return pointer;
}

\end{verbatim}

\section{make_original_file_list.c}
\begin{verbatim}
#include "function.h"

void insert_cell_f(struct cell_f **pointer, char *main_title, char *sub_title, char *date, char *path, int category)
{
  struct cell_f *new_cell;

  new_cell = (struct cell_f *)malloc(sizeof(struct cell_f));

  new_cell->main_title = (char *)malloc(strlen(main_title) + 1);
  new_cell->sub_title = (char *)malloc(strlen(sub_title) + 1);
  new_cell->date = (char *)malloc(strlen(date) + 1);
  new_cell->path = (char *)malloc(strlen(path) + 1);

  strcpy(new_cell->main_title, main_title);
  strcpy(new_cell->sub_title, sub_title);
  strcpy(new_cell->date, date);
  strcpy(new_cell->path, path);
  new_cell->category = category;

  new_cell->next = *pointer;
  *pointer = new_cell;
}

struct cell_f **make_original_file_list(struct cell_f **pointer, FILE *fp)
{
  struct cell_f **p;
  int category;
  char main[MAXLEN], sub[MAXLEN], date[MAXLEN], path[MAXLEN];

  p = pointer;

  while(fscanf(fp, "%s %s %s %s %d", main, sub, date, path, &category) != EOF){
    insert_cell_f(p, main, sub, date, path, category);
    p = &((*p)->next);
  }

  return pointer;
}

\end{verbatim}

\section{print.c}
\begin{verbatim}
#include "function.h"

void print_f(struct cell_f *p)
{
  if(p == NULL){
    printf("一致するファイルはありませんでした。\n");
    return;
  }

  while(p != NULL){
    printf("%s %s %s %s %d\n", p->main_title, p->sub_title, p->date, p->path, p->category);
    p = p->next;
  }
}

void print_c(struct cell_c *p)
{
  if(p == NULL){
    printf("一致する分類項目はありませんでした。\n");
    return;
  }

  while(p != NULL){
    printf("%d %s\n", p->number, p->category);
    p = p->next;
  }
}

\end{verbatim}

\section{search_existing_file.c}
\begin{verbatim}
#include "function.h"

void search_f(struct cell_f **h_f, struct cell_f **pointer)
{
  struct cell_f *head = NULL;
  struct cell_f **result;

  char data[MAXLEN];
  char key[MAXLEN];


  printf("どのデータで検索しますか？数字を入力してください。\n");
  printf("0: タイトル 1: 副タイトル 2: 作成日付 3: パス名 4: 分類項目名\n");
  printf(">");
  scanf("%s", data);

  if(strlen(data) > 1){
    printf("入力エラーです。\n");
    return;
  }

  if('0' >= data[0] || data[0] >= '4'){
    printf("入力エラーです。\n");
    return;
  }

  printf("キーを入力してください。\n");
  printf(">");
  scanf("%s", key);

  result = search_file(h_f, (*pointer), atoi(data), key);

  if((*result) == NULL){
    printf("一致するデータはありませんでした。\n");
    return;
  }
  else if((*result)->next != NULL)
    sort(result);

  print_f((*result));
}

/* ファイルを捜しリストを作る */
struct cell_f **search_file(struct cell_f **h_f, struct cell_f *pointer, int number, char *key)
{
  struct cell_f **p;
  char main[MAXLEN], sub[MAXLEN], date[MAXLEN], path[MAXLEN];
  int category;

  p = h_f;

  if(pointer == NULL)
    return NULL;

  if(number == 0){
    while(pointer != NULL){
      if(strcmp(pointer->main_title, key) == 0){
        strcpy(main, pointer->main_title);
        strcpy(sub, pointer->sub_title);
        strcpy(date, pointer->date);
        strcpy(path, pointer->path);
        category = pointer->category;

        insert_cell_f(p, main, sub, date, path, category);
        p = &((*p)->next);
      }
      pointer = pointer->next;
    }
    return h_f;
  }
	
  else if(number == 1){
    while(pointer != NULL){
      if(strcmp(pointer->sub_title, key) == 0){
        strcpy(main, pointer->main_title);
        strcpy(sub, pointer->sub_title);
        strcpy(date, pointer->date);
        strcpy(path, pointer->path);
        category = pointer->category;

        insert_cell_f(p, main, sub, date, path, category);
        p = &((*p)->next);
      }
      pointer = pointer->next;
    }
    return h_f;
  }

  else if(number == 2){
    while(pointer != NULL){
      if(strcmp(pointer->date, key) == 0){
        strcpy(main, pointer->main_title);
        strcpy(sub, pointer->sub_title);
        strcpy(date, pointer->date);
        strcpy(path, pointer->path);
        category = pointer->category;

        insert_cell_f(p, main, sub, date, path, category);
        p = &((*p)->next);
      }
      pointer = pointer->next;
    }
    return h_f;
  }

  else if(number == 3){
    while(pointer != NULL){
      if(strcmp(pointer->path, key) == 0){
        strcpy(main, pointer->main_title);
        strcpy(sub, pointer->sub_title);
        strcpy(date, pointer->date);
        strcpy(path, pointer->path);
        category = pointer->category;

        insert_cell_f(p, main, sub, date, path, category);
        p = &((*p)->next);
      }
      pointer = pointer->next;
    }
    return h_f;
  }

  else if(number == 4){
    while(pointer != NULL){
      if(pointer->category == atoi(key)){
        strcpy(main, pointer->main_title);
        strcpy(sub, pointer->sub_title);
        strcpy(date, pointer->date);
        strcpy(path, pointer->path);
        category = pointer->category;

        insert_cell_f(p, main, sub, date, path, category);
        p = &((*p)->next);
      }
      pointer = pointer->next;
    }
    return h_f;
  }
}

\end{verbatim}

\section{sort.c}
\begin{verbatim}
#include "function.h"

void sort(struct cell_f **pointer)
{
  char c[MAXLEN];

  printf("複数のファイルが表示されます。ソート方法を選択してください。\n");
  printf("0: タイトル昇順副タイトル昇順 1: タイトル昇順副タイトル降順 2: タイトル降順副タイトル昇順 3: タイトル降順副タイトル降順 4: 作成日付昇順 5: 作成日付降順 6: パス名昇順 7: パス名降順 8: 分類名降順 9: 分類名降順\n");
  printf(">");
  scanf("%s", c);

  if(strlen(c) > 1){
    printf("入力エラーです。\n");
    return;
  }

  switch (c[0]) {
  case '0':
    m_a_sub_a(pointer);

  case '1':
    m_a_sub_d(pointer);

  case '2':
    m_d_sub_a(pointer);

  case '3':
    m_d_sub_d(pointer);

  case '4':
    date_a(pointer);

  case '5':
    date_d(pointer);

  case '6':
    path_a(pointer);

  case '7':
    path_d(pointer);

  case '8':
    category_a(pointer);

  case '9':
    category_d(pointer);

  default:
    printf("入力エラーです。\n");
  }

}

/* 指定されたノードへのポインタを返す */
struct cell_f *search(struct cell_f *pointer, int n)
{
  int i;

  if(pointer == NULL)
    return NULL;
  else if(n == 1)
    return pointer;
  else{
    for(i = 0; i < n - 1; i++)
      pointer = pointer->next;
  }

  return pointer;
}

/* 要素の入れ替え */
void change(struct cell_f *data, int x, int y)
{
  struct cell_f *tmp, *a, *b;

  tmp = (struct cell_f *)malloc(sizeof(struct cell_f));

  a = search(data, x);
  b = search(data, y);

  tmp->main_title = a->main_title;
  tmp->sub_title = a->sub_title;
  tmp->date = a->date;
  tmp->path = a->path;
  tmp->category = a->category;

  a->main_title = b->main_title;
  a->sub_title = b->sub_title;
  a->date = b->date;
  a->path = b->path;
  a->category = b->category;

  b->main_title = tmp->main_title;
  b->sub_title = tmp->sub_title;
  b->date = tmp->date;
  b->path = tmp->path;
  b->category = tmp->category;
}

void category_a(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_category_a((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_category_a((*pointer), 1, j - 1);
  }
}

void downheap_category_a(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  if(right != NULL && (left->category <= right->category) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  if(upper->category <= lower->category){
    change(data, v, w);
    downheap_category_a(data, w, n);
  }
}

void category_d(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_category_d((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_category_d((*pointer), 1, j - 1);
  }
}

void downheap_category_d(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && (left->category >= right->category) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if(upper->category >= lower->category){
    change(data, v, w);
    downheap_category_d(data, w, n);
  }
}

void date_a(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_date_a((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_date_a((*pointer), 1, j - 1);
  }
}

void downheap_date_a(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && ((strcmp(left->date, right->date)) < 0) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->date, lower->date)) <= 0){
    change(data, v, w);
    downheap_date_a(data, w, n);
  }
}

void date_d(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_date_d((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_date_d((*pointer), 1, j - 1);
  }
}

void downheap_date_d(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && ((strcmp(left->date, right->date)) > 0) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->date, lower->date)) >= 0){
    change(data, v, w);
    downheap_date_d(data, w, n);
  }
}

void m_a_sub_a(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_main_a_sub_a((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_main_a_sub_a((*pointer), 1, j - 1);
  }
}

void downheap_main_a_sub_a(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && (((strcmp(left->main_title, right->main_title)) < 0) || ((strcmp(left->main_title, right->main_title)) == 0) && ((strcmp(left->sub_title, right->sub_title)) < 0)) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->main_title, lower->main_title)) == 0){
    if((strcmp(upper->sub_title, lower->sub_title)) < 0){
      change(data, v, w);
      downheap_main_a_sub_a(data, w, n);
    }
  }

  else if((strcmp(upper->main_title, lower->main_title)) < 0){
    change(data, v, w);
    downheap_main_a_sub_a(data, w, n);
  }
}

void m_a_sub_d(struct cell_f **pointer)
{
  int i, j, k;
  struct cell_f *q;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_main_a_sub_d((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_main_a_sub_d((*pointer), 1, j - 1);
  }
}

void downheap_main_a_sub_d(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && (((strcmp(left->main_title, right->main_title)) < 0) || ((strcmp(left->main_title, right->main_title)) == 0) && ((strcmp(left->sub_title, right->sub_title)) > 0)) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->main_title, lower->main_title)) == 0){
    if((strcmp(upper->sub_title, lower->sub_title)) > 0){
      change(data, v, w);
      downheap_main_a_sub_d(data, w, n);
    }
  }

  else if((strcmp(upper->main_title, lower->main_title)) < 0){
    change(data, v, w);
    downheap_main_a_sub_d(data, w, n);
  }
}

void m_d_sub_a(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--)
    downheap_main_a_sub_d((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_main_a_sub_d((*pointer), 1, j - 1);
  }
}

void downheap_main_d_sub_a(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && (((strcmp(left->main_title, right->main_title)) > 0) || ((strcmp(left->main_title, right->main_title)) == 0) && ((strcmp(left->sub_title, right->sub_title)) < 0)) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->main_title, lower->main_title)) == 0){
    if((strcmp(upper->sub_title, lower->sub_title)) < 0){
      change(data, v, w);
      downheap_main_a_sub_d(data, w, n);
    }
  }

  else if((strcmp(upper->main_title, lower->main_title)) > 0){
    change(data, v, w);
    downheap_main_a_sub_d(data, w, n);
  }
}

void m_d_sub_d(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_main_d_sub_d((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_main_d_sub_d((*pointer), 1, j - 1);
  }
}

void downheap_main_d_sub_d(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && (((strcmp(left->main_title, right->main_title)) > 0) || ((strcmp(left->main_title, right->main_title)) == 0) && ((strcmp(left->sub_title, right->sub_title)) > 0)) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->main_title, lower->main_title)) == 0){
    if((strcmp(upper->sub_title, lower->sub_title)) > 0){
      change(data, v, w);
      downheap_main_d_sub_d(data, w, n);
    }
  }

  else if((strcmp(upper->main_title, lower->main_title)) > 0){
    change(data, v, w);
    downheap_main_d_sub_d(data, w, n);
  }
}

void path_a(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;
	
  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_path_a((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_path_a((*pointer), 1, j - 1);
  }
}

void downheap_path_a(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && ((strcmp(left->path, right->path)) < 0) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);    
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->path, lower->path)) <= 0){
    change(data, v, w);
    downheap_path_a(data, w, n);
  }
}

void path_d(struct cell_f **pointer)
{
  struct cell_f *q;
  int i, j, k;

  q = (*pointer);

  for(k = 0; q != NULL; k++)
    q = q->next;

  for (i = k; 0 < i; i--) 
    downheap_path_d((*pointer), i, k);

  for (j = k; 1 < j; j--){
    change((*pointer), 1, j);
    downheap_path_d((*pointer), 1, j - 1);
  }
}

void downheap_path_d(struct cell_f *data, int v, int n)
{
  int w;
  struct cell_f *left, *right, *upper, *lower;

  /* vが子ノードを持たない場合 */
  if(v > n / 2)
    return;

  left = search(data, 2 * v);
  right = search(data, 2 * v + 1);

  /* 右の子ノードがあるかつ右の子の方が大きい場合 */
  if(right != NULL && ((strcmp(left->path, right->path)) > 0) && (2 * v + 1) <= n)
    w = 2 * v + 1;
	
  else
    w = 2 * v;

  upper = search(data, v);
  lower = search(data, w);

  /* vよりもwの値が大きい */
  if((strcmp(upper->path, lower->path)) >= 0){
    change(data, v, w);
    downheap_path_d(data, w, n);
  }
}

\end{verbatim}

\section{sub_function.c}
\begin{verbatim}
#include "function.h"

void sub_function(struct cell_f **pointer)
{
  FILE *fp;
  char string[MAX];
  char sub_title[MAXLEN];
  int i;
  struct cell_f *p, *q;

  struct cell_f *head = NULL;
  struct cell_f **result;

  struct cell_f *h_f = NULL;

  char main[MAXLEN];
  char sub[MAXLEN];

  /* あいうえお */

  printf("コメントを抽出表示します。\n");
  
 printf("検索するファイルのタイトル名を入力してください。\n");
  printf(">");
  scanf("%s", main);

  printf("検索するファイルの副タイトル名を入力してください。\n");
  printf(">");
  scanf("%s", sub);

  p = *pointer;

  while(p != NULL && (strcmp(p->main_title, main)) != 0 && (strcmp(p->sub_title, sub)) != 0){
    q = p;
    p = p->next;
  }

  if(p == NULL){
    printf("一致するファイルはありませんでした。\n");
    return;
  }

  else
    printf("%s %s %s %s %d\n", p->main_title, p->sub_title, p->date, p->path, p->category);

   sprintf(sub_title, "%s%s", p->path, p->main_title);


  /* かきくけこ */

  if ((fp = fopen(sub_title, "r")) == NULL){
    fprintf(stderr, "Cannot open file: %s\n", sub_title);
    return;
  }

  while(fgets(string, MAX - 1, fp) != NULL){
    for(i = 0; string[i] != '/'; i++){
    }
    if(string[i + 1] == '*')
      printf("%s", string);
  }

  /* さしすせそ */
  fclose(fp);
}

\end{verbatim}
\end{document}